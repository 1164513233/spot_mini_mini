#!/usr/bin/env python
"""
DESCRIPTION:

SUBSCRIBERS:
"""

from __future__ import division
import rospy
import numpy as np
from mini_ros.msg import MiniCmd
from ars_lib.ars import ARSAgent, Normalizer, Policy
from mini_bullet.minitaur_gym_env import MinitaurBulletEnv

import torch
import os


class SpotCommander():
    def __init__(self):

        rospy.init_node('Policies', anonymous=True)
        self.agents = {}
        # self.movetypes = [
        #     "Forward", "Backward", "Left", "Right", "CW", "CCW", "Stop"
        # ]
        self.movetypes = ["Stop", "Forward", "Backward", "Left", "CW", "CCW"]
        self.mini_cmd = MiniCmd()
        self.mini_cmd.motion = "Stop"
        self.mini_cmd.velocity = 0.0
        self.mini_cmd.rate = 0.0

        self.load_minitaur()
        # print("AGENTS: ", self.agents)
        # callback from mini_cmd topic
        self.sub = rospy.Subscriber('mini_cmd', MiniCmd, self.callback)
        print("READY TO GO!")

    def load_minitaur(self):
        print("Loading various Minitaur Policies")

        self.file_name = "mini_ars_"
        # Find abs path to this file
        my_path = os.path.abspath(os.path.dirname(__file__))
        self.models_path = os.path.join(my_path, "../policies")

        if not os.path.exists(self.models_path):
            os.makedirs(self.models_path)

        self.env = MinitaurBulletEnv(render=True, env_randomizer=None)

        self.env.reset()

        seed = 0
        # Set seeds
        self.env.seed(seed)
        torch.manual_seed(seed)
        np.random.seed(seed)

        state_dim = self.env.observation_space.shape[0]
        print("STATE DIM: {}".format(state_dim))
        action_dim = self.env.action_space.shape[0]
        print("ACTION DIM: {}".format(action_dim))
        max_action = float(self.env.action_space.high[0])
        print("RECORDED MAX ACTION: {}".format(max_action))

        self.state = np.zeros(state_dim)

        # Initialize Normalizer
        self.normalizer = Normalizer(state_dim)
        # Initialize Policy
        policy = Policy(state_dim, action_dim)

        # Populate Agent Dictionary
        for movetype in self.movetypes:
            self.agents[movetype] = self.load_policy(movetype, self.normalizer,
                                                     policy)
        # NOTE: MANUAL OVERRIDE
        self.agents["Stop"] = ARSAgent(self.normalizer, policy, self.env)

    def load_policy(self, agent_type, normalizer, policy):
        agent = ARSAgent(normalizer, policy, self.env)
        if agent_type != "Stop":
            if os.path.exists(self.models_path + "/" + self.file_name +
                              agent_type + "_policy"):
                print("Loading Agent: " + agent_type)
                agent.load(self.models_path + "/" + self.file_name +
                           agent_type)
                agent.policy.episode_steps = 1e12
        return agent

    def deploy(self, agent):
        # NOTE Using Global Normalizer
        self.normalizer.observe(self.state)
        # Normalize State
        self.state = self.normalizer.normalize(self.state)
        action = agent.policy.evaluate(self.state, None, None)
        # Clip action between +-1 for execution in env
        for a in range(len(action)):
            action[a] = np.clip(action[a], -agent.max_action, agent.max_action)
        self.state, reward, done, _ = self.env.step(action)
        # print("STATE: ", self.state)
        # print("ACTION: ", action)
        reward = np.clip(reward, -agent.max_action, agent.max_action)
        return reward

    def callback(self, mini_cmd):
        """ Reads the desired Minitaur command and passes it for execution

            Args: mini_cmd
        """
        try:
            # Update mini_cmd
            self.mini_cmd = mini_cmd
            # log input data as debug-level message
            rospy.logdebug(mini_cmd)
        except rospy.ROSInterruptException:
            pass

    def move(self):
        # For now there are no velocity commands.
        # print("COMMAND: ", self.mini_cmd.motion)
        # self.mini_cmd.motion = "Forward"
        agent = self.agents[self.mini_cmd.motion]
        _ = self.deploy(agent)

    def move2(self):
        # For now there are no velocity commands.
        # print("COMMAND: ", self.mini_cmd.motion)
        # self.mini_cmd.motion = "Forward"
        agent = self.agents["Forward"]
        agent.deploy()


def main():
    """ The main() function. """
    mini_commander = SpotCommander()
    rate = rospy.Rate(200)
    while not rospy.is_shutdown():
        # This is called continuously. Has timeout functionality too
        mini_commander.move()
        rate.sleep()
        # rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass