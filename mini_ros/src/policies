#!/usr/bin/env python
"""
DESCRIPTION:

SUBSCRIBERS:
"""

from __future__ import division
import rospy
import numpy as np
from mini_ros.msg import MiniCmd
from ars_lib.ars import ARSAgent, Normalizer, Policy
from mini_bullet.minitaur_gym_env import MinitaurBulletEnv

import torch
import os


class MiniCommander():
    def __init__(self):

        rospy.init_node('Policies', anonymous=True)
        self.agents = {}
        # self.movetypes = [
        #     "Forward", "Backward", "Left", "Right", "CW", "CCW", "Stop"
        # ]
        self.movetypes = [
            "Stop", "Forward", "Backward", "Left", "CW", "CCW"
        ]
        self.state = None
        self.mini_cmd = MiniCmd()
        self.mini_cmd.motion = "Stop"
        self.mini_cmd.velocity = 0.0
        self.mini_cmd.rate = 0.0

        self.load_minitaur()
        print("AGENTS: ", self.agents)
        # callback from mini_cmd topic
        self.sub = rospy.Subscriber('mini_cmd', MiniCmd, self.callback)
        print("READY TO GO!")

    def load_minitaur(self):
        print("Loading various Minitaur Policies")

        self.file_name = "mini_ars_"
        # Find abs path to this file
        my_path = os.path.abspath(os.path.dirname(__file__))
        self.models_path = os.path.join(my_path, "../policies")

        if not os.path.exists(self.models_path):
            os.makedirs(self.models_path)

        self.env = MinitaurBulletEnv(render=True)

        seed = 0
        # Set seeds
        self.env.seed(seed)
        torch.manual_seed(seed)
        np.random.seed(seed)

        state_dim = self.env.observation_space.shape[0]
        print("STATE DIM: {}".format(state_dim))
        action_dim = self.env.action_space.shape[0]
        print("ACTION DIM: {}".format(action_dim))
        max_action = float(self.env.action_space.high[0])
        print("RECORDED MAX ACTION: {}".format(max_action))

        self.state = self.env.reset(self.mini_cmd.velocity, self.mini_cmd.rate)

        # Initialize Normalizer
        normalizer = Normalizer(state_dim)
        # Initialize Policy
        policy = Policy(state_dim, action_dim)
        # Initialize Agent with normalizer, policy gym env, and initial state
        agent = ARSAgent(normalizer, policy, self.env)

        # Populate Agent Dictionary
        for movetype in self.movetypes:
            self.agents[movetype] = self.load_policy(movetype, normalizer, policy)
        # NOTE: MANUAL OVERRIDE
        self.agents["Stop"] = ARSAgent(normalizer, policy, self.env)

    def load_policy(self, agent_type, normalizer, policy):
        agent = ARSAgent(normalizer, policy, self.env)
        if agent_type != "Stop":
            if os.path.exists(self.models_path + "/" + self.file_name +
                              agent_type + "_policy"):
                print("Loading Agent: " + agent_type)
                agent.load(self.models_path + "/" + self.file_name +
                           agent_type)
                agent.policy.episode_steps = 1e12
        return agent

    def deploy(self, agent):
        agent.normalizer.observe(self.state)
        # print("-----------------------")
        # Normalize State
        state = agent.normalizer.normalize(self.state)
        action = agent.policy.theta.dot(self.state)
        # Clip action between +-1 for execution in env
        for a in range(len(action)):
            action[a] = np.clip(action[a], -agent.max_action, agent.max_action)
        state, reward, done, _ = self.env.step(action)
        # Clip reward between -1 and 1 to prevent outliers from
        # distorting weights
        reward = np.clip(reward, -agent.max_action, agent.max_action)
        return state, reward

    def callback(self, mini_cmd):
        """ Reads the desired Minitaur command and passes it for execution

            Args: mini_cmd
        """
        try:
            # Update mini_cmd
            self.mini_cmd = mini_cmd
            # log input data as debug-level message
            rospy.logdebug(mini_cmd)
        except rospy.ROSInterruptException:
            pass

    def move(self):
        # For now there are no velocity commands.
        # Select agent in dict
        # print("COMMAND: ", self.mini_cmd.motion)
        agent = self.agents[self.mini_cmd.motion]
        # print("MOVING")
        # Update state (also returns reward)
        self.state, _ = self.deploy(agent)


def main():
    """ The main() function. """
    mini_commander = MiniCommander()
    rate = rospy.Rate(100)
    while not rospy.is_shutdown():
        # This is called continuously. Has timeout functionality too
        mini_commander.move()
        rate.sleep()
        # rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass